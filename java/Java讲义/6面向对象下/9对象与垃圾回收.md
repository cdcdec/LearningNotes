# 对象与垃圾回收
## 垃圾回收机制的特征
* 垃圾回收机制只负责回收堆内存中的对象,不会回收任何物理资源(包括数据库连接,网络IO等资源);
* 程序无法精确控制垃圾回收的运行,垃圾回收会在合适的时候运行;
* 在垃圾回收机制回收任何对象之前,总会先调用它的finalize()方法,该方法可能别使该对象重新复活(让一个引用变量重新引用该对象),从而导致垃圾回收机制取消回收。

## 对象在内存中的状态
* 可达状态:当一个对象被创建后,若有一个以上的引用变量引用它,则这个对象处于可达状态,程序可通过引用变量来调用该对象的Field和方法;
* 可恢复状态:如果程序中某个对象不再有任何引用变量引用它,它就进入可恢复状态.系统会调用所有对象的finalize()方法进行资源清理,这个对像可能变为可达状态也可能变为不可达状态。
* 不可达状态:这个对象永久性的失去引用,变成不可达状态.系统会回收该对象所占的资源.
## 强制垃圾回收
程序只能控制一个对象何时不被任何引用变量引用,但不能控制它何时被回收.强制垃圾回收只是通知系统进行垃圾回收,但系统是否会进行垃圾回收不确定。大部分的时候,强制进行垃圾回收会有一些效果。强制系统垃圾回收的两个方法:
    * 调用System类的gc()静态方法:System.gc();
    * 调用Runtime对象的gc()实例方法,Runtime.getRuntime().gc();
## finalize()方法
finalize()方法是系统提供的默认机制来清理该对象的资源,当finalize()方法返回后,对象消失,垃圾回收机制开始执行.任何Java类都可以重写Object类的finalize()方法,在该方法中清理该对象的资源.finalize()方法的特点:
* 永远不要主动调用某个对象的finalize()方法,该方法应交给垃圾回收机制调用;
* finalize()方法何时被调用,是否会被调用具有不稳定性,finalize()方法是一个不一定会被执行的方法;
* JVM执行可恢复对象的finalize()方法时,可能使该对象或系统中其他对象重新变成可达状态;
* 当JVM执行finalize()方法时出现异常,垃圾回收机制不会报告异常,程序继续执行;

System.runFinalization()方法和Runtime.getRuntime().runFinalization()方法,强制垃圾回收机制调用可恢复对象的finalize()方法.

## 对象的软、弱和虚引用
Java中对象的引用有如下4种方式:
* 强引用(StrongReference):最常见的引用方式;
* 软引用(SoftReference):软引用需要通过SoftReference类来实现.对于只有软引用的对象而言,当系统内存空间足够时,它不会被系统回收,程序也可使用该对象;当系统内存空间不足时,系统可能会回收它.软引用通常用于内存敏感的程序中.可以通过SoftReference类的实例方法get()获取它所引用的对象;
* 弱引用(WeakReference):弱引用需要通过WeakReference类来实现.对于只有弱引用的对象而言,当系统垃圾回收机制运行时,不管系统内存是否足够,总会回收该对象所占用的内存.可以通过WeakReference类的实例方法get()获取它所引用的对象;
* 虚引用(PhantomReference):虚引用通过PhantomReference类实现,虚引用完全类似与没有引用.虚引用对对象本身没有太大的影响.如果一个对象只有虚引用时,它和没有引用的效果大致相同.虚引用主要用于跟踪对象被垃圾回收的状态,虚引用不能单独使用,必须和引用队列(ReferenceQueue)联合使用。虚引用无法获取它所引用的对象.

>要使用这些特殊的引用类,就不能保留对对象的强引用。

