# 线程的生命周期

新建,就绪,运行,阻塞,死亡.

## 新建
new创建一个新线程后,该线程就处于新建状态,java虚拟机为其分配内存,并初始化其成员变量的值,程序不会执行线程执行体.

## 就绪
调用线程对象的start()方法后,线程就处于就绪状态,java虚拟机会为其创建方法调用栈和程序计数器,表示该线程可以运行了。但是线程何时可以运行,取决于JVM里线程调度器的调度。
>启动线程要调用start()方法,不能直接调用run()方法,如果直接调用run()方法,系统会把线程对象当作一个普通的对象,run()方法也是一个普通方法,而不是线程执行体.

>如果要让子线程立即执行,可以在主线程里面调用Thread.sleep()方法,让当前线程(主线程)休眠1毫秒,这样CPU就会去执行这个处于就绪状态的子线程.


## 运行状态
处于就绪状态的线程,获得了CPU,开始执行run()方法的线程执行体,线程就处于运行状态.

## 阻塞状态
线程在运行的过程中需要被中段,以便使其它线程获得执行的机会,线程调度的细节取决于底层平台所使用的策略.对于采用抢占式策略的系统,系统会给每个可执行的线程一个小时间段来处理任务,当该段时间用完后,系统会剥夺该线程所占用的资源,让其它线程获得执行的机会,在选择下一个线程时,系统会考虑线程的优先级.当发生下列情况时,线程将会进入阻塞状态:
* 线程调用sleep()方法,主动放弃所占用的处理器资源;
* 线程调用了一个阻塞式IO方法,在该方法返回后,该线程被阻塞;
* 线程试图获得一个同步监视器,但该同步监视器,被其它线程持有;
* 线程在等待某个通知(notify)
* 程序调用了线程的suspend()方法将该线程挂起.

当正在执行的线程被阻塞后,其它线程就可以获得执行的机会,被阻塞的线程会在适当的时候,重新进入就绪状态.
>线程从阻塞状态只能进入就绪状态,不能进入运行状态.就绪和运行状态之间的转换通常不受程序控制.

## 死亡

线程结束后,就处于死亡状态。
* run()或call()方法执行完成,线程死亡.
* 线程抛出一个未捕获的Exception或Error
* 直接调用该线程的stop()方法,结束该线程.

>主线程结束后,其它线程不受任何影响,并不会随之结束.一旦子线程启动后,其就获得了与主线程相同的地位,它不会受主线程的影响.

>线程对象的isAlive()方法,当线程处于就绪,运行,阻塞3中状态时,该方法返回true(),处于新建,死亡两种状态时,该方法返回false。









